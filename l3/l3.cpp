#include <iostream>
#include <limits.h>
#include <string.h>
#include <queue>
using namespace std;

#define MAX_ 99
/*-ЗАДАЧА РАСПИСАНИЕ --Каждый найденый путь от s до t представляет собой правильный выбор группы, комнаты, времени для одного из экзаменов,
группа при этом должна помещаться в комнату. Поиск путей заканчивается когда нет ненасыщенных цепей из истока в сток.
Каждый запуск BFS заканчивается поиском короткого пути из s в t, после в fordFulkerson на текущем найденом пути уменьшаем остаточную емкость на каждом ребре на 1 ---*/


//Метод BFS (поиск в ширину) заполняет родителей parent[] для узлов (чтобы сохранить путь), 
//Возвращает true, если есть путь от источника s к стоку t в остаточном графе. 

bool bfs(int **rGraph, int s, int t, int *parent, int V)  //  аргументы - остаточно емкостной граф (матрица емкостей), исток, сток, массив родителей, общ. кол. узлов
{
	
	// Создаем массив для отслеживания посещенных узлов, помечаем все узлы как не посещенные
	bool *visited;
	visited = new bool[V];

	for (int jj = 0; jj < V; jj++)
	{
		visited[jj] = 0;
	}

	// Создаем очередь, добавляем в очередь исходный узел и помечаем исходный узел как посещенный, "-1" значение родительских узлов для исходного узла
	queue <int> q;
	q.push(s); // добавляем элемент в очередь (в начале исходный узел всегда)
	visited[s] = true;
	parent[s] = -1;

	// Цикл поиска в ширину (в начале в очереди только исток - узел 0)
	while (!q.empty()) // пока очередь не пуста
	{
		int u = q.front(); // возвращаем первый элемент в очереди
		q.pop(); // удаляем первый элемент из очереди

		for (int v = 0; v<V; v++)  // перебираем все узлы подряд  0...V для текущего u, находим смежные и доб. в очередь, помечаем родителей, отмечаем посещенными
		{
			    if ( (visited[v] == false) && (rGraph[u][v] > 0) ) //если текущий узел не посещен и 
				  {													// тек. ребро имеет остаточную емкость >0  
					q.push(v); // вставляем в очередь текущий узел
					parent[v] = u; // указываем для текущего узла родителя удаленного из очереди до начала этого цикла 
					visited[v] = true; // указываем текущий узел как посещенный						
				 }
		}
	}

	// Если мы достигли стока при BFS то возвращаем true, в противном случае false
	return (visited[t] == true);
}

// Возвращает максимальный поток из s в t в заданом графе
int fordFulkerson(int **graph, int s, int t, int V) // принимает исх. матрицу смежности, номер узлов истока и стока, кол-во узлов
{
	int u, v;

	//Создаем остаточный емкостной граф и заполняем его в начале заданными емкостями ребер из исх. матрицы смежности
	int** rGraph;  //Остаточный граф rGraph [i][j], который указывает остаточную емкость (пропускную способность) ребра от i до j (если есть ребро), если rGraph [i][j] равно 0, то ребра нет
	rGraph = new int*[V];
	for (int i = 0; i < V; i++) 
		rGraph[i] = new int[V];


	for (u = 0; u < V; u++) 
		for (v = 0; v < V; v++)
			rGraph[u][v] = graph[u][v]; // заполняем граф ост. емкостной (в начале заданными емкостями ребер из исх. матрицы смежности)

	int *parent;  // Массив родителей узлов заполняет метод BFS для сохранения каждого найденного пути (для каждой новой итерации)
	parent = new int[V];

	int max_flow = 0;  // В начале поток нулевой

	int schet_ekz = 0; // общее количество возможных экзаменов
	cout << endl << "- Р А С П И С А Н И Е   Э К З А М Е Н О В -" << endl;
	cout << "Экзамен Уз.-1 Время Аудитория Группа"<< endl; // распечатка пути 	


	while (bfs(rGraph, s, t, parent, V)) //Увеличиваем поток на каждой итерации, пока есть путь от источника к стоку
	{
		//Ищем минимальную остаточную емкость ребер вдоль пути, заполненного BFS (находим макс. поток через найденный BFS путь, всегда будет 1).
		int path_flow = INT_MAX; //в начале поток максимален  - для оценки 

		schet_ekz++; // cчетчик общ. кол-ва экзаменов
		cout << " №" << schet_ekz <<":" <<'\t'; // распечатка пути 

		for (v = t; v != s; v = parent[v]) // для текущего найденого пути перебираем вершины в обратном порядке (от стока t к источнику s)
		{
			u = parent[v];  // присваеваем переменной u номер родительского узла для текущего узла
			path_flow = min(path_flow, rGraph[u][v]); // возвращает минимальное из двух значений: текущий макс. поток , остаточная емкость на текущей дуге
														// по текущему пути от t к s
			cout << v << '\t'; // распечатка пути
		}
		cout << endl;

		// обновим остаточные емкости ребер вдоль текущего пути
		for (v = t; v != s; v = parent[v])
		{
			u = parent[v];
			rGraph[u][v] -= path_flow; // вычитаем найденый максимальный поток на текущем пути 
			//rGraph[v][u] += path_flow;  убираем, т.к. нам нужны только прямые пути, макс поток найдем выбором единственной минимально доступной комнаты для группы
		}

		// Добавляем найденый поток на текущем пути к общему макс. потоку графа
		max_flow += path_flow;
	}

	// Возвращаем макс. поток графа (общее количество экзаменов которое можно провести)
	return max_flow;
}


int main()
{
	setlocale(LC_ALL, "RUS");
	// Создаем граф с исходными пропускными способностями дуг (по данным пользователя)
	int i, j;
	int M; // размер матрицы смежности
	int Group_num; // количество групп
	int *Group_size; // массив - количество студентов в каждой из групп
	int Komnat_num; // количество комнат
	int *Komnat_size; //массив -  количество мест в каждой из комнат
	int Time_num; // количество временных слотов
	

	////// создание матрицы смежности (с исходными пропускными способностями дуг ) согласно данных пользователя 
	
	cout << "Это программа создает расписание экзаменов" << endl <<
		"с использованием алгоритм Эдмондса — Карпа (поиск доп. кратчайших путей поиском в ширину,"<<endl<< 
		"без перераспределения потока)." << endl << endl

		<<"Введите количество групп студентов:" <<endl;
	cin >> Group_num;
	cout << "Введите количество студентов в каждой из групп (каждый раз нажимая -Enter-):" << endl;
	
	Group_size = new int[Group_num+1]; // массив - количество студентов в каждой из групп	
	for (int kk = 0; kk < Group_num + 1; kk++) Group_size[kk] = 0; // заполняем массив нулями 

	for (i = 1; i<=Group_num; i++)
	{
		cin >> Group_size[i];
	}
	//Сортировка по возрастанию массива размера групп
	sort(Group_size, Group_size + Group_num + 1); // для того чтобы группа мин размера сразу занимала миним по размеру комнату (второй аргумент длинна)
	

	cout << "Введите количество количество аудиторий доступных для проведения экзаменов:" << endl;
	cin >> Komnat_num;
	cout << "Введите количество мест в каждой из аудиторий (каждый раз нажимая -Enter-):" << endl;

	Komnat_size = new int[Komnat_num+ Group_num+1]; //массив - количество мест в каждой из комнат
	for (int kn = 0; kn < Komnat_num + Group_num + 1; kn++) Komnat_size[kn] = 0; // заполняем массив нулями 

	for (i = (Group_num + 1); i<=(Komnat_num+ Group_num); i++)
	{
		cin >> Komnat_size[i];
	}
	//Сортировка по возрастанию массива размера комнат
	sort(Komnat_size, Komnat_size + Komnat_num + Group_num + 1);  // для того чтобы группа мин размера сразу занимала миним по размеру комнату
	
	
	cout << "Введите количество временных слотов:" << endl;
	cin >> Time_num;

	M = Group_num + Komnat_num + Time_num + 2; // количество узлов в графе (2 - сток и исток)

	int** matrix;
	matrix = new int*[M]; // создание матрицы смежности
	for (i = 0; i < M; i++) 
		matrix[i] = new int[M];

	// первоначально заполняем матрицу нулями
	for (i = 0; i < M; i++)
	{
		for (j = 0; j < M; j++)
		{
			matrix[i][j]=0;
		}
	}
	// заполняем матрицу весами - от истока к группам (i = 0, j = 1..Group_num) - вес каждого ребра равен количеству временных слотов
	
		for (j = 1; j <= Group_num; j++)
		{
			matrix[0][j] = Time_num; // количеству временных слотов (так как в максимальном случае каждая группа может использовать все слоты времени)
		}
		
	// заполняем матрицу весами - от групп к комнатам (i = 1..Group_num; j = Group_num+1...Group_num + Komnat_num) - вес каждого ребра "неограничен"

		for (i = 1; i <= Group_num; i++)
		{
			for (j = (Group_num + 1); j <= (Group_num + Komnat_num); j++)
			{
				if (Komnat_size[j] >= Group_size[i])  //проверка чтобы хватило мест в комнате для группы
													// используем ранее составленные массивы для групп и комнат
				
				matrix[i][j] = MAX_;
			}
		}
		
		
	// заполняем матрицу весами - от комнат к временным слотам (i = Group_num+1...Group_num+Komnat_num, 
		// j = Group_num+Komnat_num+1...Group_num+Komnat_num+Time_num) - вес каждого ребра 1 (т.к. нельзя одновременнно быть в нескольких разных комнатах)
		for (i = (Group_num + 1); i <= (Group_num+ Komnat_num); i++)
		{
			for (j = (Group_num + Komnat_num +1); j <= (Group_num + Komnat_num + Time_num); j++)
			{
				matrix[i][j] = 1;
			}			
		}

		// заполняем матрицу весами - от временных слотов к стоку (строка M-1) - вес каждого ребра неограничен
				
			for (i = (Group_num + Komnat_num +1); i <= (Group_num + Komnat_num + Time_num); i++)
			{
				matrix[i][M-1] = MAX_;
			}
		

		// Распечатываем получившуюся матрицу
		cout << "Матрица смежности согласно ваших данных:" << endl;
		for (i = 0; i < M; i++)
		{
			for (j = 0; j < M; j++)
			{ 
				cout << matrix[i][j] << '\t';
			}
			cout << endl;
		}


	int ekz = fordFulkerson(matrix, 0, M - 1, M); // вызов метода реализующего алг. Эдмондса — Карпа (модифицированый алгоритм Форда- Фалкерсона)


	cout << "Общее количество экзаменов которое можно провести: " << ekz << endl;
	
	if (Group_num*Time_num > ekz) cout << "Исходя из заданых условий нельзя провести экзамены абсолютно для всех групп." << endl;

	// распечатка легенды -  номера групп и комнат соответственно от количества людей из исходного задания
	cout << endl << "------------ ЛЕГЕНДА ---------- " << endl;
	cout << "Группа №    Количество студентов" << endl;

	for (i = 1; i <= Group_num; i++)
	{
		cout << "  " << i << '\t' << '\t' << Group_size[i] << endl;
	}

	cout << "Аудитория №   Количество мест" << endl;
	for (i = (Group_num + 1); i <= (Komnat_num + Group_num); i++)
	{
		cout << "  " << i << '\t' << '\t' <<Komnat_size[i] << endl;
	}
	
	cin.get();
	cin.get();

	return 0;
}